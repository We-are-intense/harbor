## 0x01 äº’æ–¥é—®é¢˜å’Œ Peterson ç®—æ³•
### äº’æ–¥

**æ’å…¥ â€œç¥ç§˜ä»£ç â€ï¼Œä½¿å¾—æ‰€æœ‰å…¶ä»– â€œç¥ç§˜ä»£ç â€ éƒ½ä¸èƒ½å¹¶å‘**

``` c hl_lines="3-4"
void Tsum() {
  stop_the_world();
  // ä¸´ç•ŒåŒº critical section
  sum++;
  resume_the_world();
}
```

Stop the world çœŸçš„æ˜¯å¯èƒ½çš„:

- Java æœ‰ â€œstop the world GCâ€
- å•ä¸ªå¤„ç†å™¨å¯ä»¥å…³é—­ä¸­æ–­
- å¤šä¸ªå¤„ç†å™¨ä¹Ÿå¯ä»¥å‘é€æ ¸é—´ä¸­æ–­

### å¤±è´¥çš„å°è¯•

``` c
int locked = UNLOCK;

void critical_section() {
retry:
  if (locked != UNLOCK) {
    goto retry;
  }
  locked = LOCK;

  // critical section

  locked = UNLOCK;
}
```

==å¹¶å‘ç¨‹åºä¸èƒ½ä¿è¯ load + store çš„åŸå­æ€§==

### æ›´ä¸¥è‚ƒåœ°å°è¯•ï¼šç¡®å®šå‡è®¾ã€è®¾è®¡ç®—æ³•
å‡è®¾ï¼šå†…å­˜çš„è¯»/å†™å¯ä»¥ä¿è¯é¡ºåºã€åŸå­å®Œæˆ

- val = atomic_load(ptr)
    - çœ‹ä¸€çœ¼æŸä¸ªåœ°æ–¹çš„å­—æ¡ (åªèƒ½çœ‹åˆ°ç¬é—´çš„å­—)
    - åˆšçœ‹å®Œå°±å¯èƒ½è¢«æ”¹æ‰
- atomic_store(ptr, val)
    - å¯¹åº”å¾€æŸä¸ªåœ°æ–¹ â€œè´´ä¸€å¼ çº¸æ¡â€ (å¿…é¡»é—­çœ¼ç›²è´´)
    - è´´å®Œä¸€ç¬é—´å°±å¯èƒ½è¢«åˆ«äººè¦†ç›–

### Peterson ç®—æ³•

A å’Œ B äº‰ç”¨å•æ‰€çš„åŒ…å¢

- æƒ³è¿›å…¥åŒ…å¢ä¹‹å‰ï¼ŒA/B éƒ½é¦–å…ˆä¸¾èµ·è‡ªå·±çš„æ——å­
    - A å¾€å•æ‰€é—¨ä¸Šè´´ä¸Š â€œB æ­£åœ¨ä½¿ç”¨â€ çš„æ ‡ç­¾
    - B å¾€å•æ‰€é—¨ä¸Šè´´ä¸Š â€œA æ­£åœ¨ä½¿ç”¨â€ çš„æ ‡ç­¾
- ç„¶åï¼Œå¦‚æœå¯¹æ–¹ä¸¾ç€æ——ï¼Œä¸”é—¨ä¸Šçš„åå­—æ˜¯å¯¹æ–¹ï¼Œç­‰å¾…
    - å¦åˆ™å¯ä»¥è¿›å…¥åŒ…å¢
- å‡ºåŒ…å¢åï¼Œæ”¾ä¸‹è‡ªå·±çš„æ——å­ (å®Œå…¨ä¸ç®¡é—¨ä¸Šçš„æ ‡ç­¾)

### æšä¸¾çŠ¶æ€
æšä¸¾çŠ¶æ€æœºçš„å…¨éƒ¨çŠ¶æ€ (PC~1~, PC~2~, x, y, turn)

```c
void TA() { while (1) {
/* â¶ */  x = 1;
/* â· */  turn = B;
/* â¸ */  while (y && turn == B) ;
/* â¹ */  x = 0; } }

void TB() { while (1) {
/* â‘  */  y = 1;
/* â‘¡ */  turn = A;
/* â‘¢ */  while (x && turn == A) ;
/* â‘£ */  y = 0; } }
```

``` py linenums="1"
def T1():
  while heap.lock != 'âœ…':
    sys_sched()
  sys_sched()
  heap.lock = 'âŒ'
  sys_write('â¶')

def T2():
  while heap.lock != 'âœ…':
    sys_sched()
  sys_sched()
  heap.lock = 'âŒ'
  sys_write('â·')

def main():
  heap.lock = 'âœ…'
  sys_spawn(T1)
  sys_spawn(T2)

# Outputs:
# â¶â·
# â·â¶
```

## 0x02 Peterson ç®—æ³•çš„æ­£ç¡®æ€§å’Œæ¨¡å‹æ£€éªŒ

=== "model checker"
    Peterson ç®—æ³•æ¯”é‚£äº› â€œç©å…·â€ çš„ä¾‹å­å¤æ‚å¾—å¤šï¼Œâ€œéšæ—¶éšåœ°â€ éƒ½æœ‰å‘ç”Ÿçº¿ç¨‹åˆ‡æ¢çš„å¯èƒ½æ€§ã€‚è¿™äº›å¯èƒ½æ€§å¯¹äºæ‰‹å·¥æšä¸¾æ¥è¯´ï¼Œå·²ç»æœ‰äº›å¤ªè¿‡çç¢äº†â€”â€”è¿™ä¹Ÿæ˜¯åœ¨å¾ˆé•¿ä¸€æ®µæ—¶é—´é‡Œï¼Œå¤§å®¶ç»™å‡ºé”™è¯¯äº’æ–¥ç®—æ³•çš„åŸå› ã€‚è€Œè¯¸å¦‚ â€œx, y, turnâ€ã€â€œ0ã€1â€ è¿™äº›æŠ½è±¡çš„æ•°å€¼ï¼Œè¿›ä¸€æ­¥å¢åŠ äº†äººè„‘åœ¨æ€è€ƒè¿™äº›é—®é¢˜æ—¶çš„è´Ÿæ‹…ã€‚æˆ‘ä»¬ä½¿ç”¨ Emoji æ¥ç¼“è§£è¿™ä¸€ç‚¹â€”â€”ä¾‹å¦‚ç”¨ ğŸ´ è¡¨ç¤ºç¬¬ä¸€ä¸ªçº¿ç¨‹ä¸¾èµ·æ——å­å¸Œæœ›è¿›å…¥ä¸´ç•ŒåŒºã€‚è¿™æ¯” x = 1 è¦æ›´ç›´è§‚ã€‚

    ``` shell
    python3 mosaic.py -c peterson.py | grep cs | sort | uniq -c
    ```

=== "æ¨¡å‹æ£€éªŒ"

    ``` py
    def T1():
      while True:
        heap.x = 'ğŸ´'
        sys_sched()
        heap.turn = 'â·'
        sys_sched()
        while True:
          t = heap.turn
          sys_sched()
          y = heap.y != ''
          sys_sched()
          if not y or t == 'â¶':
            break
        sys_sched()
        heap.cs += 'â¶'
        sys_sched()
        heap.cs = heap.cs.replace('â¶', '')
        sys_sched()
        heap.x = ''
        sys_sched()
     
    def T2():
      while True:
        heap.y = 'ğŸ'
        sys_sched()
        heap.turn = 'â¶'
        sys_sched()
        while True:
          t = heap.turn
          sys_sched()
          x = heap.x
          sys_sched()
          if not x or t == 'â·':
            break
          sys_sched()
        sys_sched()
        heap.cs += 'â·'
        sys_sched()
        heap.cs = heap.cs.replace('â·', '')
        sys_sched()
        heap.y = ''
        sys_sched()

    def main():
      heap.x = ''
      heap.y = ''
      heap.turn = ''
      heap.cs = ''
      sys_spawn(T1)
      sys_spawn(T2)
    ```


=== "Peterson å®ç°"

    **ä»£ç ç¤ºä¾‹ï¼šPeterson ç®—æ³•å®ç°**

    åœ¨ç°ä»£å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šï¼Œæˆ‘ä»¬é¢ä¸´ç¼–è¯‘å™¨ã€å¤„ç†å™¨çš„åŒé‡å¤æ‚è¡Œä¸ºã€‚å› æ­¤ï¼Œåœ¨ç°ä»£å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šå®ç° â€œæ­£ç¡®â€ çš„ Peterson ç®—æ³•å¹¶ä¸æ˜¯ä¸€é¡¹ç®€å•çš„ä»»åŠ¡ã€‚

    å¯¹äº â€œåˆ°åº•å“ªä¸€ä¸ª barrier æ˜¯ä¸å¯ç¼ºå°‘â€ è¿™ä¸ªé—®é¢˜å·²ç»è¶…å‡ºäº†æœ¬é—¨è¯¾ç¨‹çš„è®¨è®ºèŒƒå›´ã€‚æˆ‘ä»¬è¯•å›¾ç”¨è¿™ä¸ªä¾‹å­å‘å¤§å®¶ä¼ é€’ä¸€ä¸ªæ€æƒ³ï¼šé™¤éä½ å¯¹å¤šå¤„ç†å™¨å¹¶å‘æœ‰è¶³å¤Ÿçš„ç†è§£ï¼Œè¯·ä¸è¦è‡ªä½œä¸»å¼ å†™èªæ˜çš„å¹¶å‘ç¨‹åºã€‚åœ¨ 99.9% çš„æƒ…å†µä¸‹ï¼Œä½ éƒ½å¯ä»¥åœ¨ä¸è§¦åŠæ­¤ç±»åº•å±‚è¡Œä¸ºçš„å‰æä¸‹ä¼˜åŒ–ä½ çš„ä»£ç ã€‚

=== "peterson.c"

    ``` c
    #include "thread.h"

    #define A 1
    #define B 2

    #define BARRIER __sync_synchronize()

    atomic_int nested;
    atomic_long count;

    void critical_section() {
      long cnt = atomic_fetch_add(&count, 1);
      int i = atomic_fetch_add(&nested, 1) + 1;
      if (i != 1) {
        printf("%d threads in the critical section @ count=%ld\n", i, cnt);
        assert(0);
      }
      atomic_fetch_add(&nested, -1);
    }

    int volatile x = 0, y = 0, turn;

    void TA() {
      while (1) {
        x = 1;                   BARRIER;
        turn = B;                BARRIER; // <- this is critcal for x86
        while (1) {
          if (!y) break;         BARRIER;
          if (turn != B) break;  BARRIER;
        }
        critical_section();
        x = 0;                   BARRIER;
      }
    }

    void TB() {
      while (1) {
        y = 1;                   BARRIER;
        turn = A;                BARRIER;
        while (1) {
          if (!x) break;         BARRIER;
          if (turn != A) break;  BARRIER;
        }
        critical_section();
        y = 0;                   BARRIER;
      }
    }

    int main() {
      create(TA);
      create(TB);
    }
    ```

## 0x03 å®ç°å¹¶å‘æ§åˆ¶çš„ç¡¬ä»¶å’Œç¼–è¯‘å™¨æœºåˆ¶

### åŸå­æŒ‡ä»¤



