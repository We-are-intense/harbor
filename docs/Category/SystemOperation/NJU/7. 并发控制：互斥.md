## äº’æ–¥é—®é¢˜çš„å®šä¹‰å’Œå‡è®¾

å…è®¸ä½¿ç”¨ä½¿æˆ‘ä»¬å¯ä»¥==ä¸ç®¡ä¸€åˆ‡éº»çƒ¦äº‹==çš„åŸå­æŒ‡ä»¤

``` c
void atomic_inc(long *ptr);
int atomic_xchg(int val, int *ptr);
```

!!! tip "å‡½æ•°éœ€è¦åŒ…å«å¦‚ä¸‹åŠŸèƒ½ï¼š"

        - åŒ…å«ä¸€ä¸ªåŸå­æŒ‡ä»¤ï¼ˆæŒ‡ä»¤çš„æ‰§è¡Œä¸èƒ½è¢«æ‰“æ–­ï¼‰ï¼›
        - åŒ…å«ä¸€ä¸ª compiler barrierï¼ˆæ— è®ºä½•ç§ä¼˜åŒ–éƒ½ä¸å¯è¶Šè¿‡æ­¤å‡½æ•°ï¼‰ï¼›
        - åŒ…å«ä¸€ä¸ª memory fenceï¼›
            - ä¿è¯å¤„ç†å™¨åœ¨ stop-the-world å‰æ‰€æœ‰å¯¹å†…å­˜çš„ store éƒ½ â€œç”Ÿæ•ˆâ€ï¼›
            - å³å¯¹ resume-the-world ä¹‹åçš„ load å¯è§ï¼›

Atomic Exchange å®ç°ï¼š

``` c
int xchg(int volatile *ptr, int newval) {
  int result;
  asm volatile(
    // æŒ‡ä»¤è‡ªå¸¦ memory barrier
    "lock xchgl %0, %1"
    : "+m"(*ptr), "=a"(result)
    : "1"(newval)
    // Compiler barrier
    : "memory"
  );
  return result;
}
```

## è‡ªæ—‹é” (Spin Lock)

### 1.è‡ªæ—‹é”ï¼šç”¨ xchg å®ç°äº’æ–¥

!!! tip "è‡ªæ—‹é” (Spin Lock)"

        åœ¨å•æ‰€é—¨å£æ”¾ä¸€ä¸ªæ¡Œå­ (å…±äº«å˜é‡): åˆå§‹æ—¶æ”¾ç€ ğŸ”‘;
        
        æƒ³ä¸Šå•æ‰€çš„åŒå­¦ (ä¸€æ¡ xchg æŒ‡ä»¤):

        - Stop the world
        - çœ‹ä¸€çœ¼æ¡Œå­ä¸Šæœ‰ä»€ä¹ˆ (ğŸ”‘ æˆ– ğŸ›‘)
        - æŠŠ ğŸ›‘ æ”¾åˆ°æ¡Œä¸Š (è¦†ç›–ä¹‹å‰æœ‰çš„ä»»ä½•ä¸œè¥¿)
        - Resume the world
        - æœŸé—´çœ‹åˆ° ğŸ”‘ æ‰å¯ä»¥è¿›å•æ‰€ï¼Œå¦åˆ™é‡å¤

        å‡ºå•æ‰€çš„åŒå­¦: æŠŠ ğŸ”‘ æ”¾åˆ°æ¡Œä¸Š

### 2.å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

``` c
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES);  // ä¸ºä»€ä¹ˆä¸æ˜¯ table = YES; ?
}
```
!!! tip "åœ¨ xchg çš„å‡è®¾ä¸‹ç®€åŒ–å®ç°:"

        - åŒ…å«ä¸€ä¸ªåŸå­æŒ‡ä»¤
        - åŒ…å«ä¸€ä¸ª compiler barrier
        - åŒ…å«ä¸€ä¸ª memory fence

        ``` c
        int locked = 0;

        void lock() {
            while (xchg(&locked, 1));
        }

        void unlock() {
            xchg(&locked, 0);
        }
        ```

=== "spinlock model checker"
    
    ä½¿ç”¨ model checker å¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„è¿è¡Œæƒ…å†µï¼š

    ``` shell
    python3 mosaic.py -c spinlock.py | grep stdout | sort | uniq -c

      18       "stdout": "",
       5       "stdout": "(",
      20       "stdout": "()",
       5       "stdout": "()(",
      15       "stdout": "()()",
       5       "stdout": "()()[",
      14       "stdout": "()()[]",
       5       "stdout": "()()[][",
       9       "stdout": "()()[][]",
       ......
    ```

=== "spinlock.py"

    ``` py
    def Tworker(enter, exit):
      for _ in range(2):
        while True:
          seen = heap.table
          heap.table = 'âŒ'
          sys_sched()
          if seen == 'âœ…':
            break
        sys_sched()
        sys_write(enter)
        sys_sched()
        sys_write(exit)
        sys_sched()
        heap.table = 'âœ…'
        sys_sched()

    def main():
      heap.table = 'âœ…'
      sys_spawn(Tworker, '(', ')')
      sys_spawn(Tworker, '[', ']')
    ```
### 3. sumæ±‚å’Œä½¿ç”¨è‡ªæ—‹é”

=== "sum æ±‚å’Œ"

    **ä»£ç ç¤ºä¾‹ï¼šç”¨è‡ªæ—‹é”å®ç°äº’æ–¥**

    æˆ‘ä»¬å°† sum å˜é‡çš„è®¿é—®ç”¨ lock/unlock åŒ…å›´èµ·æ¥ï¼Œä»¥å®ç°äº’æ–¥ã€‚æ³¨æ„åˆ° sum æ˜¯ä¸€ä¸ªæ™®é€šçš„å˜é‡ï¼Œèƒ½å¤Ÿä»¥å¤§å®¶ç†Ÿæ‚‰çš„æ–¹å¼è¢«ç¼–è¯‘ä¼˜åŒ– (ä¾‹å¦‚ 10 æ¬¡ sum++ å¯ä»¥è¢«ä¼˜åŒ–æˆ sum += 10)ã€‚lock/unlock ä¸­çš„ compiler barrier å’Œ memory fence ä¿è¯äº†çº¿ç¨‹é—´çš„æ•°æ®å¯ä»¥æ­£ç¡®è¯»å–ã€‚

=== "sum-spinlock.c"

    ``` c
    #include "thread.h"

    #define N 100000000
    #define M 10

    long sum = 0;

    int xchg(int volatile *ptr, int newval) {
      int result;
      asm volatile(
        "lock xchgl %0, %1"
        : "+m"(*ptr), "=a"(result)
        : "1"(newval)
        : "memory"
      );
      return result;
    }

    int locked = 0;

    void lock() {
      while (xchg(&locked, 1)) ;
    }

    void unlock() {
      xchg(&locked, 0);
    }

    void Tsum() {
      long nround = N / M;
      for (int i = 0; i < nround; i++) {
        lock();
        for (int j = 0; j < M; j++) {
          sum++;  // Non-atomic; can optimize
        }
        unlock();
      }
    }

    int main() {
      assert(N % M == 0);
      create(Tsum);
      create(Tsum);
      join();
      printf("sum = %ld\n", sum);
    }
    ```

### 4.åœ¨è‡ªæ—‹é”ä¸­ä»£æ›¿ xchg

åœ¨è‡ªæ—‹é”çš„å®ç°ä¸­ï¼Œ`xchg` å®Œå…¨å¯ä»¥ç”¨ `cmpxchg` ä»£æ›¿:

``` c
// cmpxchg(old='ğŸ”‘', new='ğŸ›‘', *ptr)
int tmp = *ptr;
if (tmp == 'ğŸ”‘') {
  *ptr = 'ğŸ›‘'
  assert(tmp == 'ğŸ”‘');
} else {
  assert(tmp == 'ğŸ›‘');
}
return tmp;

// æŠŠä¸Šè¿°ä¼ªä»£ç ä¸€äº›å‚æ•°åç§°æ”¹å˜ä¸€ä¸‹,æ¥æ›´ç²¾ç¡®è¡¨ç¤ºå…¶æ„æ€
// ptr --> é”å½“å‰çŠ¶æ€
// old --> ç”³è¯·è€…æœŸæœ›çŠ¶æ€
// new --> ç”³è¯·è€…å ç”¨é”æ—¶ç»™é”è®¾ç½®çš„çŠ¶æ€
```

å…‰çœ‹ä»£ç æˆ‘ä»¬å¾ˆéš¾ç†è§£ `cmpxchg`ï¼Œçœ‹ä¸€ä¸ªæ —å­æ¥æ„ŸçŸ¥å®ƒçš„ä½œç”¨ï¼š

ä¸‹é¢ä»¥ç«è½¦ä¸Šä¸¤ä¸ªäº’ä¸ç›¸è¯†çš„ä¹˜å®¢A,Bæ¥è®¿é—®åŒä¸€ä¸ªå«ç”Ÿé—´çš„åœºæ™¯æ¥ç†è§£ `cmpxchg` åŸç†ï¼Œ
å…¶ä¸­ä¹˜å®¢Aå…ˆæ¥åˆ°å«ç”Ÿé—´ï¼Œåœ¨æ­¤ä¹‹å‰å«ç”Ÿé—´æ²¡äººã€‚å«ç”Ÿé—´åœ¨æ²¡äººçš„æ—¶å€™ï¼Œä¼šç”¨ ğŸ”‘ æŒ‚åœ¨é—¨å£ï¼Œ
å¯ä»¥å¼€é—¨ï¼Œæœ‰äººçš„æ—¶å€™ä¼šç”¨ ğŸ›‘ æŒ‚åœ¨é—¨å£ï¼Œæ— æ³•å¼€é—¨ï¼Œä¼ªä»£ç å¦‚ä¸‹ï¼š

``` c
// ç«è½¦æŸè½¦å¢å…¬å…±å«ç”Ÿé—´çš„é” lock_state_cur
lock_state_cur == ğŸ”‘;// è¡¨ç¤ºæ­¤æ—¶å«ç”Ÿé—´æ²¡äºº
lock_state_cur == ğŸ›‘;// è¡¨ç¤ºæ­¤æ—¶å«ç”Ÿé—´æœ‰äºº


//æ­¤æ—¶è¿‡æ¥ä¸€ä¸ªä¹˜å®¢Aæƒ³è¦ä½¿ç”¨å«ç”Ÿé—´
lock_state_cur == ğŸ”‘;// è¡¨ç¤ºæ­¤æ—¶å«ç”Ÿé—´æ²¡äºº
lock_state_exp == ğŸ”‘;// ä¹˜å®¢Aå¸Œæœ›å«ç”Ÿé—´æ²¡äºº
lock_state_use == ğŸ›‘;// ä¹˜å®¢Aæ­£åœ¨ä½¿ç”¨å«ç”Ÿé—´æ—¶å¸Œæœ›å¤–é¢äººçŸ¥é“å«ç”Ÿé—´æ­¤æ—¶æœ‰äºº

//cmpxchg ä¼šå…ˆä¸Šé”,ç„¶åè¿”å› ğŸ”‘,ä»¥å‘ŠçŸ¥ä¹˜å®¢Aå¯ä»¥ä½¿ç”¨å«ç”Ÿé—´.
cmpxchg(cur, exp, use) returns ğŸ”‘;
```

æ­¤æ—¶ä¹˜å®¢Bä¹Ÿæ¥äº†ï¼Œå‘ç°å«ç”Ÿé—´æœ‰äººäº†ï¼Œå³å«ç”Ÿé—´æ˜¾ç¤ºä¸Šé”äº†(lock_state_cur == ğŸ›‘)ï¼Œ
é‚£ä¹ˆä¹˜å®¢Båªèƒ½åœ¨å«ç”Ÿé—´å¤–ç­‰å¾…ï¼Œä¼ªä»£ç å¦‚ä¸‹ï¼š

``` c
lock_state_cur == ğŸ›‘;// æ­¤æ—¶å«ç”Ÿé—´æœ‰äºº,ä¹˜å®¢Aåœ¨é‡Œé¢
lock_state_exp == ğŸ”‘;// ä¹˜å®¢Bå¸Œæœ›å«ç”Ÿé—´æ²¡äºº
lock_state_use == ğŸ›‘;// ä¹˜å®¢Bæ­£åœ¨ä½¿ç”¨å«ç”Ÿé—´æ—¶å¸Œæœ›å¤–é¢äººçŸ¥é“å«ç”Ÿé—´æ­¤æ—¶æœ‰äºº

// cmpxchgå‘ç°é”å½“å‰çŠ¶æ€ä¸ºä¸Šé”çŠ¶æ€,åˆ™ä¼šç›´æ¥è¿”å› ğŸ›‘,ä»¥å‘ŠçŸ¥ä¹˜å®¢Bæ­¤æ—¶å«ç”Ÿé—´æœ‰äºº.
cmpxchg(cur, exp, use) returns ğŸ›‘;// ğŸ›‘ è¡¨æ˜å«ç”Ÿé—´æœ‰äºº,ä¹˜å®¢Båªèƒ½ç­‰å¾…
```

ä¹˜å®¢Bç­‰å¾…çš„æ“ä½œæ˜¯ï¼Œæ—¶ä¸æ—¶çŸä¸€çœ¼å«ç”Ÿé—´ï¼Œå¦‚æœå«ç”Ÿé—´å¼€é”äº†ï¼Œé‚£ä¹ˆä¹˜å®¢Bå°±èƒ½è¿›å…¥å«ç”Ÿé—´ï¼Œå…¶ä»–ä¹˜å®¢ä»¥æ­¤ç±»æ¨ã€‚

``` c title="cmpxchg çš„å®ç°"
#include <stdio.h>
#include <assert.h>

int cmpxchg(int old, int new, int volatile *ptr) {
  asm volatile(
    "lock cmpxchgl %[new], %[mem]"
      : "+a"(old), [mem] "+m"(*ptr)
      : [new] "S"(new)
      : "memory"
  );
  return old;
}

int cmpxchg_ref(int old, int new, int volatile *ptr) {
  int tmp = *ptr;  // Load
  if (tmp == old) {
    *ptr = new;  // Store (conditionally)
  }
  return tmp;
}

void run_test(int x, int old, int new) {
  int val1 = x;
  int ret1 = cmpxchg(old, new, &val1);

  int val2 = x;
  int ret2 = cmpxchg_ref(old, new, &val2);

  assert(val1 == val2 && ret1 == ret2);
  printf("x = %d -> (cmpxchg %d -> %d) -> x = %d\n", x, old, new, val1);
}

int main() {
  for (int x = 0; x <= 2; x++)
    for (int old = 0; old <= 2; old++)
      for (int new = 0; new <= 2; new++)
        run_test(x, old, new);
}
```

## è‡ªæ—‹é”çš„ç¼ºé™·

**æ€§èƒ½é—®é¢˜ (1)ï¼š**

- é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬ï¼›
- äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½ï¼›

**æ€§èƒ½é—®é¢˜ (2)ï¼š**

- æŒæœ‰è‡ªæ—‹é”çš„çº¿ç¨‹å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»ï¼›
    - æ“ä½œç³»ç»Ÿä¸ â€œæ„ŸçŸ¥â€ çº¿ç¨‹åœ¨åšä»€ä¹ˆ
- å®ç° 100% çš„èµ„æºæµªè´¹ï¼ˆä¸€æ ¸æœ‰éš¾å…«æ ¸å›´è§‚ï¼‰ï¼›

### 1.Scalability: æ€§èƒ½çš„æ–°ç»´åº¦

!!! warning

    åŒä¸€ä»½è®¡ç®—ä»»åŠ¡ï¼Œæ—¶é—´ (CPU cycles) å’Œç©ºé—´ (mapped memory) ä¼šéšå¤„ç†å™¨æ•°é‡çš„å¢é•¿è€Œå˜åŒ–ã€‚

<div class="result" markdown>

![spinlock-scalability](images/spinlock-scalability.jpg){ align=right width=400 }

ç”¨è‡ªæ—‹é”å®ç° sum++ çš„æ€§èƒ½é—®é¢˜ï¼Œä¸¥è°¨çš„ç»Ÿè®¡å¾ˆéš¾ï¼š

- CPU åŠ¨æ€åŠŸè€—
- ç³»ç»Ÿä¸­çš„å…¶ä»–è¿›ç¨‹
- è¶…çº¿ç¨‹
- NUMA
- ...
- [Benchmarking crimes](https://gernot-heiser.org/benchmarking-crimes.html)

</div>

### 2.è‡ªæ—‹é”çš„ä½¿ç”¨åœºæ™¯
1. ä¸´ç•ŒåŒºå‡ ä¹ä¸ â€œæ‹¥å µâ€
2. æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢

ä½¿ç”¨åœºæ™¯ï¼š==æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„ (çŸ­ä¸´ç•ŒåŒº)==

- æ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å 
    - ä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”
- (å¦‚æœæ˜¯è™šæ‹Ÿæœºå‘¢...ğŸ˜‚)
    - PAUSE æŒ‡ä»¤ä¼šè§¦å‘ VM Exit
- ä½†ä¾æ—§å¾ˆéš¾åšå¥½
    - [An analysis of Linux scalability to many cores](https://www.usenix.org/conference/osdi10/analysis-linux-scalability-many-cores) (OSDI'10)

### 3.å®ç°çº¿ç¨‹ + é•¿ä¸´ç•ŒåŒºçš„äº’æ–¥
ä½†æœ‰ä¸€ç§ç‰¹æ®Šçš„æŒ‡ä»¤ï¼š`syscall`

- æŠŠé”çš„å®ç°æ”¾åˆ°æ“ä½œç³»ç»Ÿé‡Œå°±å¥½å•¦
    - syscall(SYSCALL_lock, &lk);
      - è¯•å›¾è·å¾— lkï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹
    - syscall(SYSCALL_unlock, &lk);
      - é‡Šæ”¾ lkï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’

### 4.å…³äºäº’æ–¥çš„ä¸€äº›åˆ†æ

<div class="result" markdown>

`è‡ªæ—‹é” (çº¿ç¨‹ç›´æ¥å…±äº« locked)`

:   - æ›´å¿«çš„ fast path
        - xchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
    - æ›´æ…¢çš„ slow path  
        - xchg å¤±è´¥ â†’ æµªè´¹ CPU è‡ªæ—‹ç­‰å¾…

`äº’æ–¥é” (é€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—® locked)`

:   - æ›´ç»æµçš„ slow path
        - ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨ CPU
    - æ›´æ…¢çš„ fast path
        - å³ä¾¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸ (syscall)

</div>

### 5.è‡ªæ—‹é”æ±‚å’Œçš„ Scalability

=== "ç¤ºä¾‹ï¼šsum-scalability"

    **ä»£ç ç¤ºä¾‹ï¼šè‡ªæ—‹é”æ±‚å’Œçš„ Scalability**

    å¦‚æœæŠŠå¤š sum++ å‡åŒ€åœ°åˆ†åˆ° n ä¸ªçº¿ç¨‹ï¼Œå°†ä¼šå¾—åˆ°ä»€ä¹ˆæ ·çš„ç»“æœï¼Ÿ

    ä¸´ç•ŒåŒºçš„ä»£ç ä¸èƒ½å¹¶è¡Œâ€”â€”å› æ­¤æ— è®ºå¼€å¯å¤šå°‘ä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œ sum++ æŒ‡ä»¤çš„æ•°é‡æ˜¯å®Œå…¨ç›¸åŒçš„ã€‚ç„¶è€Œï¼Œå› ä¸ºå¤šä¸ªå¤„ç†å™¨ä¹‹é—´äº‰æŠ¢é”å’Œ sum å˜é‡ï¼Œå°†ä¼šå¼•èµ·ç¼“å­˜ä¸€è‡´æ€§åè®®çš„é¢å¤–å¼€é”€ã€‚éšç€çº¿ç¨‹æ•°é‡çš„å¢é•¿ï¼Œç¨‹åºçš„æ•ˆç‡é€æ¸é™ä½ã€‚ä¸ºäº†è§‚å¯Ÿåˆ°è¿™ä¸€ç°è±¡ï¼Œä½ éœ€è¦åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šè¿è¡Œè¿™ä¸ªç¨‹åºã€‚

=== "sum-scalability.c"

    ``` c
    #include "thread.h"
    #include "thread-sync.h"

    #define N 10000000
    spinlock_t lock = SPIN_INIT();

    long n, sum = 0;

    void Tsum() {
      for (int i = 0; i < n; i++) {
        spin_lock(&lock);
        sum++;
        spin_unlock(&lock);
      }
    }

    int main(int argc, char *argv[]) {
      assert(argc == 2);
      int nthread = atoi(argv[1]);
      n = N / nthread;
      for (int i = 0; i < nthread; i++) {
        create(Tsum);
      }
      join();
      assert(sum == n * nthread);
    }
    ```

=== "thread-sync.h"

    ``` c
    #include <semaphore.h>

    // Spinlock
    typedef int spinlock_t;
    #define SPIN_INIT() 0

    static inline int atomic_xchg(volatile int *addr, int newval) {
      int result;
      asm volatile ("lock xchg %0, %1":
        "+m"(*addr), "=a"(result) : "1"(newval) : "memory");
      return result;
    }

    void spin_lock(spinlock_t *lk) {
      while (1) {
        intptr_t value = atomic_xchg(lk, 1);
        if (value == 0) {
          break;
        }
      }
    }
    void spin_unlock(spinlock_t *lk) {
      atomic_xchg(lk, 0);
    }

    // Mutex
    typedef pthread_mutex_t mutex_t;
    #define MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER
    void mutex_lock(mutex_t *lk)   { pthread_mutex_lock(lk); }
    void mutex_unlock(mutex_t *lk) { pthread_mutex_unlock(lk); }

    // Conditional Variable
    typedef pthread_cond_t cond_t;
    #define COND_INIT() PTHREAD_COND_INITIALIZER
    #define cond_wait pthread_cond_wait
    #define cond_broadcast pthread_cond_broadcast
    #define cond_signal pthread_cond_signal

    // Semaphore
    #define P sem_wait
    #define V sem_post
    #define SEM_INIT(sem, val) sem_init(sem, 0, val)
    ```

### 6.ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤ä¸´ç•ŒåŒº

=== "ç¤ºä¾‹ï¼šsum-mutex"

    **ä»£ç ç¤ºä¾‹ï¼šä½¿ç”¨äº’æ–¥é”ä¿æŠ¤ä¸´ç•ŒåŒº**

    æ“ä½œç³»ç»Ÿä¸ºæˆ‘ä»¬æä¾›äº†äº’æ–¥é”ï¼Œä»¥åº”å¯¹å¤šå¤„ç†å™¨è‡ªæ—‹å¸¦æ¥çš„ CPU æµªè´¹ã€‚äº’æ–¥é”ä¼šå…ˆè¯•ç€è‡ªæ—‹ï¼›å¦‚æœæ²¡èƒ½è·å¾—é”ï¼Œåˆ™ä¼šè¿›å…¥ Slow Pathï¼Œç”±æ“ä½œç³»ç»Ÿæ¥ç®¡é”çš„å®ç°ã€‚ç”±äºæ— æ³•é¢„çŸ¥å¤šä¹…åé”æ‰ä¼šè¢«é‡Šæ”¾ï¼Œæ“ä½œç³»ç»Ÿä¼šå°†ä¸Šé”çš„çº¿ç¨‹æš‚åœå¹¶ä¸å†è°ƒåº¦å®ƒï¼Œç›´åˆ°æŒæœ‰é”çš„çº¿ç¨‹é‡Šæ”¾é”ä¸ºæ­¢ã€‚

    ä»ä½¿ç”¨çš„è§’åº¦ï¼Œäº’æ–¥é”çš„è¡Œä¸ºä¸è‡ªæ—‹é”å®Œå…¨ç›¸åŒ (é™¤äº†æ›´å°‘çš„ CPU æµªè´¹)ã€‚

=== "sum-mutex.c"

    ``` c
    #include "thread.h"
    #include "thread-sync.h"

    mutex_t lock = MUTEX_INIT();

    long sum = 0;

    void Tsum() {
      mutex_lock(&lock);
      sum++;
      mutex_unlock(&lock);
    }

    int main() {
      create(Tsum);
      create(Tsum);
      join();
      printf("sum = %ld\n", sum);
    }
    ```

=== "init.gdb"

    ``` shell
    file a.out
    start
    set scheduler-locking on
    b Tsum
    c
    info threads
    ```
## Take-away Messages

ä¸ºäº†å®ç°ç°ä»£å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šçš„äº’æ–¥ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦ç†è§£ â€œåŸå­æ“ä½œâ€ (ä¾‹å¦‚ atomic_xchg) çš„å‡è®¾ï¼š

1. æ“ä½œæœ¬èº«æ˜¯åŸå­çš„ã€çœ‹èµ·æ¥æ— æ³•è¢«æ‰“æ–­çš„ï¼Œå³å®ƒçœŸçš„æ˜¯ä¸€ä¸ª â€œåŸå­æ“ä½œâ€ï¼›
2. æ“ä½œè‡ªå¸¦ä¸€ä¸ª compiler barrierï¼Œé˜²æ­¢ä¼˜åŒ–è·¨è¿‡å‡½æ•°è°ƒç”¨ã€‚è¿™ä¸€ç‚¹å¾ˆé‡è¦â€”â€”ä¾‹å¦‚æˆ‘ä»¬ä»Šå¤©çš„ç¼–è¯‘å™¨æ”¯æŒ Link-time Optimization (LTO)ï¼Œå¦‚æœç¼ºå°‘ compiler barrierï¼Œç¼–è¯‘ä¼˜åŒ–å¯ä»¥ç©¿è¿‡ volatile æ ‡è®°çš„æ±‡ç¼–æŒ‡ä»¤ï¼›
3. æ“ä½œè‡ªå¸¦ä¸€ä¸ª memory barrierï¼Œä¿è¯æ“ä½œæ‰§è¡Œå‰æŒ‡ä»¤çš„å†™å…¥ï¼Œèƒ½å¯¹å…¶ä»–å¤„ç†å™¨ä¹‹åçš„ load å¯è§ã€‚

åœ¨æ­¤å‡è®¾çš„åŸºç¡€ä¸Šï¼ŒåŸå­æ“ä½œå°±æˆä¸ºäº†æˆ‘ä»¬ç®€åŒ–ç¨‹åºæ‰§è¡Œçš„åŸºç¡€æœºåˆ¶ã€‚é€šè¿‡è‡ªæ—‹ (spin)ï¼Œå¯ä»¥å¾ˆç›´è§‚åœ°å®ç° â€œè½®è¯¢â€ å¼çš„äº’æ–¥ã€‚è€Œä¸ºäº†èŠ‚çº¦å…±äº«å†…å­˜çº¿ç¨‹åœ¨è‡ªæ—‹ä¸Šæµªè´¹çš„å¤„ç†å™¨ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨è¯·æ±‚æ“ä½œç³»ç»Ÿæ¥å¸®åŠ©ç°æˆå®Œæˆäº’æ–¥ã€‚


[^1]: [æ“ä½œç³»ç»Ÿï¼šè®¾è®¡ä¸å®ç° (2023 æ˜¥å­£å­¦æœŸ)](https://jyywiki.cn/OS/2023/)
[^2]: [7. å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥](https://jyywiki.cn/OS/2023/build/lect7.ipynb)
[^3]: [å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥ (é—®é¢˜å®šä¹‰ä¸å‡è®¾ï¼›è‡ªæ—‹é”ï¼›äº’æ–¥é”) [å—äº¬å¤§å­¦2023æ“ä½œç³»ç»Ÿ-P7] (è’‹ç‚å²©)](https://www.bilibili.com/video/BV1dY4y197xD/?spm_id_from=333.788&vd_source=fa5dc8f5e6ad21c0ac06fd4bd377e40f)
[^4]: [cmpxchgåŸç†](https://zhuanlan.zhihu.com/p/618184942)