## äº’æ–¥é—®é¢˜çš„å®šä¹‰å’Œå‡è®¾

å…è®¸ä½¿ç”¨ä½¿æˆ‘ä»¬å¯ä»¥==ä¸ç®¡ä¸€åˆ‡éº»çƒ¦äº‹==çš„åŸå­æŒ‡ä»¤

``` c
void atomic_inc(long *ptr);
int atomic_xchg(int val, int *ptr);
```

!!! tip "å‡½æ•°éœ€è¦åŒ…å«å¦‚ä¸‹åŠŸèƒ½ï¼š"

        - åŒ…å«ä¸€ä¸ªåŸå­æŒ‡ä»¤ï¼ˆæŒ‡ä»¤çš„æ‰§è¡Œä¸èƒ½è¢«æ‰“æ–­ï¼‰ï¼›
        - åŒ…å«ä¸€ä¸ª compiler barrierï¼ˆæ— è®ºä½•ç§ä¼˜åŒ–éƒ½ä¸å¯è¶Šè¿‡æ­¤å‡½æ•°ï¼‰ï¼›
        - åŒ…å«ä¸€ä¸ª memory fenceï¼›
            - ä¿è¯å¤„ç†å™¨åœ¨ stop-the-world å‰æ‰€æœ‰å¯¹å†…å­˜çš„ store éƒ½ â€œç”Ÿæ•ˆâ€ï¼›
            - å³å¯¹ resume-the-world ä¹‹åçš„ load å¯è§ï¼›

Atomic Exchange å®ç°ï¼š

``` c
int xchg(int volatile *ptr, int newval) {
  int result;
  asm volatile(
    // æŒ‡ä»¤è‡ªå¸¦ memory barrier
    "lock xchgl %0, %1"
    : "+m"(*ptr), "=a"(result)
    : "1"(newval)
    // Compiler barrier
    : "memory"
  );
  return result;
}
```

## è‡ªæ—‹é” (Spin Lock)

### 1.è‡ªæ—‹é”ï¼šç”¨ xchg å®ç°äº’æ–¥

!!! tip "è‡ªæ—‹é” (Spin Lock)"

        åœ¨å•æ‰€é—¨å£æ”¾ä¸€ä¸ªæ¡Œå­ (å…±äº«å˜é‡): åˆå§‹æ—¶æ”¾ç€ ğŸ”‘;
        
        æƒ³ä¸Šå•æ‰€çš„åŒå­¦ (ä¸€æ¡ xchg æŒ‡ä»¤):

        - Stop the world
        - çœ‹ä¸€çœ¼æ¡Œå­ä¸Šæœ‰ä»€ä¹ˆ (ğŸ”‘ æˆ– ğŸ›‘)
        - æŠŠ ğŸ›‘ æ”¾åˆ°æ¡Œä¸Š (è¦†ç›–ä¹‹å‰æœ‰çš„ä»»ä½•ä¸œè¥¿)
        - Resume the world
        - æœŸé—´çœ‹åˆ° ğŸ”‘ æ‰å¯ä»¥è¿›å•æ‰€ï¼Œå¦åˆ™é‡å¤

        å‡ºå•æ‰€çš„åŒå­¦: æŠŠ ğŸ”‘ æ”¾åˆ°æ¡Œä¸Š

### 2.å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

``` c
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES);  // ä¸ºä»€ä¹ˆä¸æ˜¯ table = YES; ?
}
```
!!! tip "åœ¨ xchg çš„å‡è®¾ä¸‹ç®€åŒ–å®ç°:"

        - åŒ…å«ä¸€ä¸ªåŸå­æŒ‡ä»¤
        - åŒ…å«ä¸€ä¸ª compiler barrier
        - åŒ…å«ä¸€ä¸ª memory fence

        ``` c
        int locked = 0;

        void lock() {
            while (xchg(&locked, 1));
        }

        void unlock() {
            xchg(&locked, 0);
        }
        ```

=== "spinlock model checker"
    
    ä½¿ç”¨ model checker å¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„è¿è¡Œæƒ…å†µï¼š

    ``` shell
    python3 mosaic.py -c spinlock.py | grep stdout | sort | uniq -c

      18       "stdout": "",
       5       "stdout": "(",
      20       "stdout": "()",
       5       "stdout": "()(",
      15       "stdout": "()()",
       5       "stdout": "()()[",
      14       "stdout": "()()[]",
       5       "stdout": "()()[][",
       9       "stdout": "()()[][]",
       ......
    ```

=== "spinlock.py"

    ``` py
    def Tworker(enter, exit):
      for _ in range(2):
        while True:
          seen = heap.table
          heap.table = 'âŒ'
          sys_sched()
          if seen == 'âœ…':
            break
        sys_sched()
        sys_write(enter)
        sys_sched()
        sys_write(exit)
        sys_sched()
        heap.table = 'âœ…'
        sys_sched()

    def main():
      heap.table = 'âœ…'
      sys_spawn(Tworker, '(', ')')
      sys_spawn(Tworker, '[', ']')
    ```
### 3. sumæ±‚å’Œä½¿ç”¨è‡ªæ—‹é”

=== "sum æ±‚å’Œ"

    **ä»£ç ç¤ºä¾‹ï¼šç”¨è‡ªæ—‹é”å®ç°äº’æ–¥**

    æˆ‘ä»¬å°† sum å˜é‡çš„è®¿é—®ç”¨ lock/unlock åŒ…å›´èµ·æ¥ï¼Œä»¥å®ç°äº’æ–¥ã€‚æ³¨æ„åˆ° sum æ˜¯ä¸€ä¸ªæ™®é€šçš„å˜é‡ï¼Œèƒ½å¤Ÿä»¥å¤§å®¶ç†Ÿæ‚‰çš„æ–¹å¼è¢«ç¼–è¯‘ä¼˜åŒ– (ä¾‹å¦‚ 10 æ¬¡ sum++ å¯ä»¥è¢«ä¼˜åŒ–æˆ sum += 10)ã€‚lock/unlock ä¸­çš„ compiler barrier å’Œ memory fence ä¿è¯äº†çº¿ç¨‹é—´çš„æ•°æ®å¯ä»¥æ­£ç¡®è¯»å–ã€‚

=== "sum-spinlock.c"

    ``` c
    #include "thread.h"

    #define N 100000000
    #define M 10

    long sum = 0;

    int xchg(int volatile *ptr, int newval) {
      int result;
      asm volatile(
        "lock xchgl %0, %1"
        : "+m"(*ptr), "=a"(result)
        : "1"(newval)
        : "memory"
      );
      return result;
    }

    int locked = 0;

    void lock() {
      while (xchg(&locked, 1)) ;
    }

    void unlock() {
      xchg(&locked, 0);
    }

    void Tsum() {
      long nround = N / M;
      for (int i = 0; i < nround; i++) {
        lock();
        for (int j = 0; j < M; j++) {
          sum++;  // Non-atomic; can optimize
        }
        unlock();
      }
    }

    int main() {
      assert(N % M == 0);
      create(Tsum);
      create(Tsum);
      join();
      printf("sum = %ld\n", sum);
    }
    ```

### 4.åœ¨è‡ªæ—‹é”ä¸­ä»£æ›¿ xchg

åœ¨è‡ªæ—‹é”çš„å®ç°ä¸­ï¼Œ`xchg` å®Œå…¨å¯ä»¥ç”¨ `cmpxchg` ä»£æ›¿:

``` c
// cmpxchg(old='ğŸ”‘', new='ğŸ›‘', *ptr)
int tmp = *ptr;
if (tmp == 'ğŸ”‘') {
  *ptr = 'ğŸ›‘'
  assert(tmp == 'ğŸ”‘');
} else {
  assert(tmp == 'ğŸ›‘');
}
return tmp;

// æŠŠä¸Šè¿°ä¼ªä»£ç ä¸€äº›å‚æ•°åç§°æ”¹å˜ä¸€ä¸‹,æ¥æ›´ç²¾ç¡®è¡¨ç¤ºå…¶æ„æ€
// ptr --> é”å½“å‰çŠ¶æ€
// old --> ç”³è¯·è€…æœŸæœ›çŠ¶æ€
// new --> ç”³è¯·è€…å ç”¨é”æ—¶ç»™é”è®¾ç½®çš„çŠ¶æ€
```

å…‰çœ‹ä»£ç æˆ‘ä»¬å¾ˆéš¾ç†è§£ `cmpxchg`ï¼Œçœ‹ä¸€ä¸ªæ —å­æ¥æ„ŸçŸ¥å®ƒçš„ä½œç”¨ï¼š

ä¸‹é¢ä»¥ç«è½¦ä¸Šä¸¤ä¸ªäº’ä¸ç›¸è¯†çš„ä¹˜å®¢A,Bæ¥è®¿é—®åŒä¸€ä¸ªå«ç”Ÿé—´çš„åœºæ™¯æ¥ç†è§£ `cmpxchg` åŸç†ï¼Œ
å…¶ä¸­ä¹˜å®¢Aå…ˆæ¥åˆ°å«ç”Ÿé—´ï¼Œåœ¨æ­¤ä¹‹å‰å«ç”Ÿé—´æ²¡äººã€‚å«ç”Ÿé—´åœ¨æ²¡äººçš„æ—¶å€™ï¼Œä¼šç”¨ ğŸ”‘ æŒ‚åœ¨é—¨å£ï¼Œ
å¯ä»¥å¼€é—¨ï¼Œæœ‰äººçš„æ—¶å€™ä¼šç”¨ ğŸ›‘ æŒ‚åœ¨é—¨å£ï¼Œæ— æ³•å¼€é—¨ï¼Œä¼ªä»£ç å¦‚ä¸‹ï¼š

``` c
// ç«è½¦æŸè½¦å¢å…¬å…±å«ç”Ÿé—´çš„é” lock_state_cur
lock_state_cur == ğŸ”‘;// è¡¨ç¤ºæ­¤æ—¶å«ç”Ÿé—´æ²¡äºº
lock_state_cur == ğŸ›‘;// è¡¨ç¤ºæ­¤æ—¶å«ç”Ÿé—´æœ‰äºº


//æ­¤æ—¶è¿‡æ¥ä¸€ä¸ªä¹˜å®¢Aæƒ³è¦ä½¿ç”¨å«ç”Ÿé—´
lock_state_cur == ğŸ”‘;// è¡¨ç¤ºæ­¤æ—¶å«ç”Ÿé—´æ²¡äºº
lock_state_exp == ğŸ”‘;// ä¹˜å®¢Aå¸Œæœ›å«ç”Ÿé—´æ²¡äºº
lock_state_use == ğŸ›‘;// ä¹˜å®¢Aæ­£åœ¨ä½¿ç”¨å«ç”Ÿé—´æ—¶å¸Œæœ›å¤–é¢äººçŸ¥é“å«ç”Ÿé—´æ­¤æ—¶æœ‰äºº

//cmpxchg ä¼šå…ˆä¸Šé”,ç„¶åè¿”å› ğŸ”‘,ä»¥å‘ŠçŸ¥ä¹˜å®¢Aå¯ä»¥ä½¿ç”¨å«ç”Ÿé—´.
cmpxchg(cur, exp, use) returns ğŸ”‘;
```

æ­¤æ—¶ä¹˜å®¢Bä¹Ÿæ¥äº†ï¼Œå‘ç°å«ç”Ÿé—´æœ‰äººäº†ï¼Œå³å«ç”Ÿé—´æ˜¾ç¤ºä¸Šé”äº†(lock_state_cur == ğŸ›‘)ï¼Œ
é‚£ä¹ˆä¹˜å®¢Båªèƒ½åœ¨å«ç”Ÿé—´å¤–ç­‰å¾…ï¼Œä¼ªä»£ç å¦‚ä¸‹ï¼š

``` c
lock_state_cur == ğŸ›‘;// æ­¤æ—¶å«ç”Ÿé—´æœ‰äºº,ä¹˜å®¢Aåœ¨é‡Œé¢
lock_state_exp == ğŸ”‘;// ä¹˜å®¢Bå¸Œæœ›å«ç”Ÿé—´æ²¡äºº
lock_state_use == ğŸ›‘;// ä¹˜å®¢Bæ­£åœ¨ä½¿ç”¨å«ç”Ÿé—´æ—¶å¸Œæœ›å¤–é¢äººçŸ¥é“å«ç”Ÿé—´æ­¤æ—¶æœ‰äºº

// cmpxchgå‘ç°é”å½“å‰çŠ¶æ€ä¸ºä¸Šé”çŠ¶æ€,åˆ™ä¼šç›´æ¥è¿”å› ğŸ›‘,ä»¥å‘ŠçŸ¥ä¹˜å®¢Bæ­¤æ—¶å«ç”Ÿé—´æœ‰äºº.
cmpxchg(cur, exp, use) returns ğŸ›‘;// ğŸ›‘ è¡¨æ˜å«ç”Ÿé—´æœ‰äºº,ä¹˜å®¢Båªèƒ½ç­‰å¾…
```

ä¹˜å®¢Bç­‰å¾…çš„æ“ä½œæ˜¯ï¼Œæ—¶ä¸æ—¶çŸä¸€çœ¼å«ç”Ÿé—´ï¼Œå¦‚æœå«ç”Ÿé—´å¼€é”äº†ï¼Œé‚£ä¹ˆä¹˜å®¢Bå°±èƒ½è¿›å…¥å«ç”Ÿé—´ï¼Œå…¶ä»–ä¹˜å®¢ä»¥æ­¤ç±»æ¨ã€‚

``` c title="cmpxchg çš„å®ç°"
#include <stdio.h>
#include <assert.h>

int cmpxchg(int old, int new, int volatile *ptr) {
  asm volatile(
    "lock cmpxchgl %[new], %[mem]"
      : "+a"(old), [mem] "+m"(*ptr)
      : [new] "S"(new)
      : "memory"
  );
  return old;
}

int cmpxchg_ref(int old, int new, int volatile *ptr) {
  int tmp = *ptr;  // Load
  if (tmp == old) {
    *ptr = new;  // Store (conditionally)
  }
  return tmp;
}

void run_test(int x, int old, int new) {
  int val1 = x;
  int ret1 = cmpxchg(old, new, &val1);

  int val2 = x;
  int ret2 = cmpxchg_ref(old, new, &val2);

  assert(val1 == val2 && ret1 == ret2);
  printf("x = %d -> (cmpxchg %d -> %d) -> x = %d\n", x, old, new, val1);
}

int main() {
  for (int x = 0; x <= 2; x++)
    for (int old = 0; old <= 2; old++)
      for (int new = 0; new <= 2; new++)
        run_test(x, old, new);
}
```

## è‡ªæ—‹é”çš„ç¼ºé™·





[^1]: [æ“ä½œç³»ç»Ÿï¼šè®¾è®¡ä¸å®ç° (2023 æ˜¥å­£å­¦æœŸ)](https://jyywiki.cn/OS/2023/)
[^2]: [7. å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥](https://jyywiki.cn/OS/2023/build/lect7.ipynb)
[^3]: [å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥ (é—®é¢˜å®šä¹‰ä¸å‡è®¾ï¼›è‡ªæ—‹é”ï¼›äº’æ–¥é”) [å—äº¬å¤§å­¦2023æ“ä½œç³»ç»Ÿ-P7] (è’‹ç‚å²©)](https://www.bilibili.com/video/BV1dY4y197xD/?spm_id_from=333.788&vd_source=fa5dc8f5e6ad21c0ac06fd4bd377e40f)
[^4]: [cmpxchgåŸç†](https://zhuanlan.zhihu.com/p/618184942)