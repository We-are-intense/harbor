## 同步问题的定义

!!! tip "同步(synchronization)"

        两个或者两个以上随时间变化的量在变化的过程中保持一定的相对关系

并发程序中的步调很难保持完全一致：

- 线程同步：在某个时间点共同达到相互已知的状态。

## 生产者-消费者问题
!!! tip "生产者-消费者"

        99% 的实际并发问题都可以用生产者-消费者解决！

``` c
void Tproduce() { while(1) printf("("); }
void Tconsume() { while(1) printf(")"); }
```

在 printf 前后增加代码，使得打印的括号序列满足：

- 一定是某个合法括号序列的前缀
- 括号嵌套的深度不超过 n
    - n = 3: ((())())((( 合法
    - n = 3: (((()))), (())) 不合法 

生产者-消费者问题中的同步：

- Tproduce: 等到有空位的时候才能打印左括号；
- Tconsume: 等到有多余的左括号的时候才能打印有括号；

### 1.错误的生产者-消费者实现

=== "示例：pc-cv"

    使用条件变量时，我们要注意唤醒的线程是不受控制的。因此有趣的现象可能发生 (假设 n = 1，但有多个生产者和消费者)：

    - 一个 Tconsume 和一个 Tproduce 同时处于等待状态
    - 此时打印的括号序列为 ...(，此时可以打印一个右括号
    - 此时另一个 Tconsume 开始执行，打印一个右括号，并执行 signal 唤醒一个线程
    - Tconsume 被唤醒，因此打印出 ...())

    我们看到，Tproduce 只希望唤醒消费者；Tconsume 只希望唤醒生产者，因此可以用两个条件变量解决这个问题。

=== "pc-cv.c"

    ``` c
    #include "thread.h"
    #include "thread-sync.h"

    int n, count = 0;
    mutex_t lk = MUTEX_INIT();
    cond_t cv = COND_INIT();
     
    #define CAN_PRODUCE (count < n)
    #define CAN_CONSUME (count > 0)

    void Tproduce() {
      while (1) {
        mutex_lock(&lk);
        if (!CAN_PRODUCE) {
          cond_wait(&cv, &lk);
        }
        printf("("); count++;
        cond_signal(&cv);
        mutex_unlock(&lk);
      }
    }

    void Tconsume() {
      while (1) {
        mutex_lock(&lk);
        if (!CAN_CONSUME) {
          cond_wait(&cv, &lk);
        }
        printf(")"); count--;
        cond_signal(&cv);
        mutex_unlock(&lk);
      }
    }

    int main(int argc, char *argv[]) {
      assert(argc == 3);
      n = atoi(argv[1]);
      int T = atoi(argv[2]);
      setbuf(stdout, NULL);
      for (int i = 0; i < T; i++) {
        create(Tproduce);
        create(Tconsume);
      }
    }
    ```
=== "thread-sync.h"

    ``` c
    #include <semaphore.h>

    // Spinlock
    typedef int spinlock_t;
    #define SPIN_INIT() 0

    static inline int atomic_xchg(volatile int *addr, int newval) {
      int result;
      asm volatile ("lock xchg %0, %1":
        "+m"(*addr), "=a"(result) : "1"(newval) : "memory");
      return result;
    }

    void spin_lock(spinlock_t *lk) {
      while (1) {
        intptr_t value = atomic_xchg(lk, 1);
        if (value == 0) {
          break;
        }
      }
    }
    void spin_unlock(spinlock_t *lk) {
      atomic_xchg(lk, 0);
    }

    // Mutex
    typedef pthread_mutex_t mutex_t;
    #define MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER
    void mutex_lock(mutex_t *lk)   { pthread_mutex_lock(lk); }
    void mutex_unlock(mutex_t *lk) { pthread_mutex_unlock(lk); }

    // Conditional Variable
    typedef pthread_cond_t cond_t;
    #define COND_INIT() PTHREAD_COND_INITIALIZER
    #define cond_wait pthread_cond_wait
    #define cond_broadcast pthread_cond_broadcast
    #define cond_signal pthread_cond_signal

    // Semaphore
    #define P sem_wait
    #define V sem_post
    #define SEM_INIT(sem, val) sem_init(sem, 0, val)
    ```

使用 `model-checker` 来检查：

``` python
N, Tp, Tc = 1, 2, 2

def Tproduce(nm):
  while heap.mutex != 'Yes':
    sys_sched()
  heap.mutex = 'No'
  sys_sched()
  
  if not (heap.count < N):
    heap.blocked.append(nm)
    heap.mutex = 'Yes'
    sys_sched()
    while nm in heap.blocked:
      sys_sched()
    while heap.mutex != 'Yes':
      sys_sched()
    heap.mutex = 'No'
    sys_sched()

  heap.count += 1
  sys_sched()
  sys_write('(')
  sys_sched()

  if heap.blocked:
    r = sys_choose([i for i, _ in enumerate(heap.blocked)])
    heap.blocked.pop(r)

  heap.mutex = 'Yes'

def Tconsume(nm):
  while heap.mutex != 'Yes':
    sys_sched()
  heap.mutex = 'No'
  sys_sched()
  
  if not (heap.count > 0):
    heap.blocked.append(nm)
    heap.mutex = 'Yes'
    sys_sched()
    while nm in heap.blocked:
      sys_sched()
    while heap.mutex != 'Yes':
      sys_sched()
    heap.mutex = 'No'
    sys_sched()

  heap.count -= 1
  sys_sched()
  sys_write(')')
  sys_sched()

  if heap.blocked:
    r = sys_choose([i for i, _ in enumerate(heap.blocked)])
    heap.blocked.pop(r)

  heap.mutex = 'Yes'

def main():
  heap.count = 0
  heap.mutex = 'Yes'
  heap.blocked = []

  for i in range(Tp):
    sys_spawn(Tproduce, f'Tp{i+1}')
  for i in range(Tc):
    sys_spawn(Tconsume, f'Tc{i+1}')

# Outputs:
# ()()
# ())(
```

pc-check.py 39:57 源代码


### 2.正确的生产者-消费者实现


### 3.并发计算 LCS




## 条件变量

