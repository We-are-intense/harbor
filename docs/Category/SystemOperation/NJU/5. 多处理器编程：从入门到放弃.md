## 1. å¤šå¤„ç†å™¨ç¼–ç¨‹å…¥é—¨
çº¿ç¨‹ï¼š==å…±äº«å†…å­˜çš„æ‰§è¡Œæµï¼Œæ‰§è¡Œæµæ‹¥æœ‰ç‹¬ç«‹çš„å †æ ˆ/å¯„å­˜å™¨==ã€‚

```c
#include "thread.h"

void Ta() { while (1) { printf("a"); } }
void Tb() { while (1) { printf("b"); } }

int main() {
  create(Ta);
  create(Tb);
}
```

### 1.1 ç¡®å®šçº¿ç¨‹å †æ ˆå¤§å°

=== "ç¤ºä¾‹ï¼šstack-probe"

    **ä»£ç ç¤ºä¾‹ï¼šç¡®å®šçº¿ç¨‹å †æ ˆå¤§å°**

    æˆ‘ä»¬å¯ä»¥é€šè¿‡ â€œæ— ç©·é€’å½’â€ï¼Œå¹¶åœ¨é€’å½’æ—¶é€šè¿‡å±€éƒ¨å˜é‡çš„åœ°å€æ¥ä¼°ç®—åˆ†é…ç»™çº¿ç¨‹çš„æ ˆç©ºé—´ã€‚

    ```shell
    Stack(T1) >= 8169 KB
    Stack(T1) >= 8171 KB
    Stack(T1) >= 8172 KB
    Stack(T1) >= 8174 KB
    Stack(T1) >= 8175 KB
    Stack(T1) >= 8177 KB
    [1]    2133 segmentation fault (core dumped)  ./stack.out
    ```

    ç”¨ä¸‹é¢çš„ shell å‘½ä»¤ä¹Ÿå¯ä»¥æŸ¥çœ‹ï¼š

    ```shell
    ulimit -s
    # 8192
    ```

=== "stack-probe"

    ```c
    #include "thread.h"

    void * volatile low[64];
    void * volatile high[64];

    void update_range(int T, void *ptr) {
        if (ptr < low[T]) low[T] = ptr;
        if (ptr > high[T]) high[T] = ptr;
    }

    void probe(int T, int n) {
        update_range(T, &n);
        long sz = (uintptr_t)high[T] - (uintptr_t)low[T];
        if (sz % 1024 < 32) {
            printf("Stack(T%d) >= %ld KB\n", T, sz / 1024);
        }
        probe(T, n + 1);  // Infinite recursion
    }

    void Tprobe(int T) {
        low[T] = (void *)-1;
        high[T] = (void *)0;
        update_range(T, &T);
        probe(T, 0);
    }

    int main() {
        setbuf(stdout, NULL);
        for (int i = 0; i < 4; i++) {
            create(Tprobe);
        }
    }
    ```
=== "thread.h"

    ```c
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdatomic.h>
    #include <assert.h>
    #include <unistd.h>
    #include <pthread.h>

    #define NTHREAD 64
    enum { T_FREE = 0, T_LIVE, T_DEAD, };
    struct thread {
        int id, status;
        pthread_t thread;
        void (*entry)(int);
    };

    struct thread tpool[NTHREAD], *tptr = tpool;

    void *wrapper(void *arg) {
        struct thread *thread = (struct thread *)arg;
        thread->entry(thread->id);
        return NULL;
    }

    void create(void *fn) {
        assert(tptr - tpool < NTHREAD);
        *tptr = (struct thread) {
            .id = tptr - tpool + 1,
            .status = T_LIVE,
            .entry = fn,
        };
        pthread_create(&(tptr->thread), NULL, wrapper, tptr);
        ++tptr;
    }

    void join() {
        for (int i = 0; i < NTHREAD; i++) {
            struct thread *t = &tpool[i];
            if (t->status == T_LIVE) {
            pthread_join(t->thread, NULL);
            t->status = T_DEAD;
            }
        }
    }

    __attribute__((destructor)) void cleanup() {
        join();
    }

    ```

### 1.2 æ›´æ”¹çº¿ç¨‹æ ˆçš„å¤§å°
é€šè¿‡ `pthread` åˆ›å»ºçº¿ç¨‹çš„æ—¶å€™ï¼Œå¯ä»¥è®¾å®šæ ˆçš„å¤§å°ï¼Œå°† `thread.h` ä¸­å‡½æ•° `create` æ›´æ”¹å¦‚ä¸‹ï¼š

```c hl_lines="9-16"
void create(void *fn) {
  assert(tptr - tpool < NTHREAD);
  *tptr = (struct thread) {
    .id = tptr - tpool + 1,
    .status = T_LIVE,
    .entry = fn,
  };

  pthread_t thread_id;
  /* thread å †æ ˆè®¾ç½®ä¸º10MBï¼Œstacksizeä»¥å­—èŠ‚ä¸ºå•ä½ã€‚*/
  int ret ,stacksize = 10 * 1024 * 1024; 
  pthread_attr_t attr;
  ret = pthread_attr_init(&attr); /*åˆå§‹åŒ–çº¿ç¨‹å±æ€§*/
  assert(ret == 0);
  ret = pthread_attr_setstacksize(&attr, stacksize);
  assert(ret == 0);

  pthread_create(&(tptr->thread), &attr, wrapper, tptr);
  ++tptr;
}

```

è¿™é‡Œå°†å½“å‰çº¿ç¨‹çš„å¤§å°æ›´æ”¹ä¸º `10MB`:

```shell
Stack(T3) >= 10218 KB
Stack(T3) >= 10220 KB
Stack(T3) >= 10221 KB
Stack(T3) >= 10223 KB
Stack(T3) >= 10224 KB
[1]    4033 segmentation fault (core dumped)  ./stack.out
```
## 2. æ”¾å¼ƒ (1)ï¼šåŸå­æ€§
==å…±äº«å†…å­˜== å‘Šè¯‰æˆ‘ä»¬å¯¹äºå…¨å±€çš„å˜é‡ ==x==ï¼Œå…¶å®ƒçº¿ç¨‹å¯ä»¥éšæ—¶æ›´æ”¹ ==x== çš„å€¼ï¼Œå¯¼è‡´ä¸¤æ¬¡å¯èƒ½è¯»åˆ°ä¸åŒçš„ xï¼š

```c
int x = 0;
int Tworker() {
  printf("%d\n", x);  // Global x
  printf("%d\n", x);
}
```

å¦‚ä¸‹é¢æ±‚å’Œçš„ä¾‹å­ï¼š

=== "æ±‚å’Œç»“æœ"

    æ¯æ¬¡è®¡ç®—ç»“æœä¸å°½ç›¸åŒï¼š

    ``` shell
    âœ ./sum.out 
    sum = 105627439
    âœ ./sum.out
    sum = 104261448
    âœ ./sum.out
    sum = 106720644
    âœ ./sum.out
    sum = 106128921
    ```

=== "sum.c"

    ```c
    #define N 100000000
    long sum = 0;

    void Tsum() { 
        for (int i = 0; i < N; i++) 
            sum++; 
    }

    int main() {
        create(Tsum);
        create(Tsum);
        join();
        printf("sum = %ld\n", sum);
    }
    ```

é€šè¿‡æŸ¥çœ‹åæ±‡ç¼–å¯ä»¥çœ‹åˆ°ï¼š

``` asm
0000000000001348 <Tsum>:
    1348:       f3 0f 1e fa             endbr64 
    134c:       55                      push   %rbp
    134d:       48 89 e5                mov    %rsp,%rbp
    1350:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    1357:       eb 16                   jmp    136f <Tsum+0x27>
    1359:       48 8b 05 e0 32 00 00    mov    0x32e0(%rip),%rax        # 4640 <sum>
    1360:       48 83 c0 01             add    $0x1,%rax
    1364:       48 89 05 d5 32 00 00    mov    %rax,0x32d5(%rip)        # 4640 <sum>
    136b:       83 45 fc 01             addl   $0x1,-0x4(%rbp)
    136f:       81 7d fc ff e0 f5 05    cmpl   $0x5f5e0ff,-0x4(%rbp)
    1376:       7e e1                   jle    1359 <Tsum+0x11>
    1378:       90                      nop
    1379:       90                      nop
    137a:       5d                      pop    %rbp
    137b:       c3                      ret 
```

==Tsum== å‡½æ•°åŒ…å«äº†å¤šæ¡æŒ‡ä»¤å®ç° ==sum++==ï¼ŒåŸå­æ€§è‡ªç„¶å°±ä¿è¯ä¸äº†ã€‚

å¦‚æœç”¨ ==-O2== æ¥ç¼–è¯‘ï¼Œå¾ˆå¥‡æ€ªï¼Œå®ƒç¥å¥‡çš„å°±å¯¹äº†ï¼Œæ±‡ç¼–å¦‚ä¸‹ï¼š

``` asm
0000000000001230 <Tsum>:
    1230:       f3 0f 1e fa             endbr64 
    1234:       48 81 05 01 2e 00 00    addq   $0x5f5e100,0x2e01(%rip)        # 4040 <sum>
    123b:       00 e1 f5 05 
    123f:       c3                      ret 
```

==$0x5f5e100 æ­£å¥½æ˜¯ Nï¼Œç¼–è¯‘å™¨è·³è¿‡ for å¾ªç¯ç›´æ¥è®¡ç®—å‡ºäº†ç»“æœ ğŸ˜‚ ~~~==

!!! æ³¨æ„

    addq å¹¶éæ˜¯åŸå­æŒ‡ä»¤ï¼Œè¿™é‡Œæ‰§è¡Œç»“æœæ­£ç¡®ä¹Ÿåªæ˜¯æ¦‚ç‡å¤§äº†è€Œå·²

å¦‚æœç”¨ ==-O1== æ¥ç¼–è¯‘ï¼Œå®ƒåˆç¥å¥‡çš„é”™äº†ï¼Œæ±‡ç¼–å¦‚ä¸‹ï¼š

``` asm
00000000000011c3 <Tsum>:
    11c3:       f3 0f 1e fa             endbr64 
    // è¯»å–å…¨å±€ sum å€¼
    11c7:       48 8b 15 72 2e 00 00    mov    0x2e72(%rip),%rdx        # 4040 <sum>
    11ce:       48 8d 42 01             lea    0x1(%rdx),%rax
    11d2:       48 81 c2 01 e1 f5 05    add    $0x5f5e101,%rdx
    11d9:       48 89 c1                mov    %rax,%rcx
    11dc:       48 83 c0 01             add    $0x1,%rax
    11e0:       48 39 d0                cmp    %rdx,%rax
    11e3:       75 f4                   jne    11d9 <Tsum+0x16>
    // å°†ç»“æœå†™å› sum
    11e5:       48 89 0d 54 2e 00 00    mov    %rcx,0x2e54(%rip)        # 4040 <sum>
    11ec:       c3                      ret 
```

==æ˜¾ç„¶ä¸¤ä¸ªçº¿ç¨‹ç¬¬ä¸€æ¬¡è¯»å– sum çš„å€¼éƒ½æ˜¯é›¶ï¼Œä¸­é—´è®¡ç®—å®Œæˆå†å†™å› sumï¼Œæœ€ç»ˆç»“æœ sum = 100000000;==

## 3. æ”¾å¼ƒ (2)ï¼šæ‰§è¡Œé¡ºåº
ä¸Šé¢çš„ä¾‹å­è¯´æ˜äº†ç¼–è¯‘æˆæœ‰å¯èƒ½å¯¼è‡´æ‰§è¡Œçš„ç»“æœä¸ä¸€æ ·ï¼›ä¸‹é¢çš„ä¾‹å­ä¹Ÿè¯´æ˜çš„è¿™ç‚¹ï¼š

```c
int done = 0;
void sum() {
    while (!done);
}
```
å¦‚æœç”¨ ==-O2== æ¥ç¼–è¯‘ï¼Œæ±‡ç¼–å¦‚ä¸‹ï¼Œç›´æ¥è¿”å›äº†ï¼š

``` asm
sum():
        ret
done:
        .zero   4
```

ä½†æ˜¯å¦‚æœ ==int volatile done = 0;== æ±‡ç¼–å¦‚ä¸‹ï¼š

``` asm
sum():
.L2:
        mov     eax, DWORD PTR done[rip]
        test    eax, eax
        je      .L2
        ret
done:
        .zero   4
```

### 3.1 ä¿è¯æ‰§è¡Œé¡ºåº
- æ’å…¥ â€œä¸å¯ä¼˜åŒ–â€ ä»£ç å¦‚ï¼š
    ``` c
    asm volatile ("" ::: "memory");
    ```
- æ ‡è®°å˜é‡ load/store ä¸ºä¸å¯ä¼˜åŒ–ï¼Œä½¿ç”¨ volatile å˜é‡å¦‚ï¼š
    ``` c hl_lines="0-1"
      extern int volatile done;

      while (!done) ;
    ```
å¦‚æœæœ‰è¿™æ ·çš„ä»£ç ï¼š

``` c
int x = 0;
void Tsum() {
    int t = x;
    t = x;
}
```
é‚£ä¹ˆç¼–è¯‘å™¨å®Œå…¨æœ‰å¯èƒ½ä¼šå°†ç¬¬äºŒè¡Œ t = x ç§»é™¤æ‰ï¼Œå¦‚æœæ’å…¥ä¸å¯ä¼˜åŒ–ï¼š

``` c hl_lines="4-4"
int x = 0;
void Tsum() {
    int t = x;
    asm volatile ("" ::: "memory");
    t = x;
}
```
ç°åœ¨ç¼–è¯‘å™¨å°±ä¸ä¼šå°†ç¬¬äºŒè¡Œ t = x ç§»é™¤æ‰äº†ã€‚

## 4. æ”¾å¼ƒ (3)ï¼šå¤„ç†å™¨é—´çš„å¯è§æ€§

``` c
int x = 0, y = 0;

void T1() {
  x = 1;     // â‘  Store(x);
  int t = y; // â‘¡ Load(y)
  printf("%d", t);
}

void T2() {
  y = 1;     // â‘¢ Store(y);
  int t = x; // â‘£ Load(x)
  printf("%d", t);
}
```

==éå†æ¨¡å‹å‘Šè¯‰æˆ‘ä»¬ï¼š01, 10, 11==

=== "ç¤ºä¾‹store-load"

    **ä»£ç ç¤ºä¾‹ï¼šçº¿ç¨‹é—´çš„å†…å­˜å¯è§æ€§**

    ä¸ºäº†æé«˜å…±äº«å†…å­˜ç³»ç»Ÿçš„æ€§èƒ½ï¼Œç³»ç»Ÿä¸­å¹¶éåªæœ‰ä¸€ä¸ª â€œå…¨å±€å…±äº«å†…å­˜â€ã€‚æ¯ä¸ªå¤„ç†å™¨éƒ½æœ‰è‡ªå·±çš„ç¼“å­˜ï¼Œ
    å¹¶ä¸”é€šè¿‡ç¡¬ä»¶å®ç°çš„åè®®ç»´æŠ¤ä¸€è‡´æ€§ã€‚åœ¨ x86 å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œå…è®¸ store æ—¶æš‚æ—¶å†™å…¥å¤„ç†å™¨æœ¬
    åœ°çš„ store bufferï¼Œä»è€Œå»¶è¿Ÿå¯¹å…¶ä»–å¤„ç†å™¨çš„å¯è§æ€§ã€‚

=== "store-load.c"

    ``` c
    #include "thread.h"
    #include <stdatomic.h>

    int x = 0, y = 0;

    atomic_int flag;
    #define FLAG atomic_load(&flag)
    #define FLAG_XOR(val) atomic_fetch_xor(&flag, val)
    #define WAIT_FOR(cond) while (!(cond)) ;

    __attribute__((noinline))
    void write_x_read_y() {
        int y_val;
        asm volatile(
            "movl $1, %0;" // x = 1
            "movl %2, %1;" // y_val = y
            : "=m"(x), "=r"(y_val) : "m"(y)
        );
        printf("%d ", y_val);
    }

    __attribute__((noinline))
    void write_y_read_x() {
        int x_val;
        asm volatile(
            "movl $1, %0;" // y = 1
            "movl %2, %1;" // x_val = x
            : "=m"(y), "=r"(x_val) : "m"(x)
        );
        printf("%d ", x_val);
    }

    void T1(int id) {
        while (1) {
            WAIT_FOR((FLAG & 1));
            write_x_read_y();
            FLAG_XOR(1);
        }
    }

    void T2() {
        while (1) {
            WAIT_FOR((FLAG & 2));
            write_y_read_x();
            FLAG_XOR(2);
        }
    }

    void Tsync() {
        while (1) {
            x = y = 0;
            __sync_synchronize(); // full barrier
            usleep(1);            // + delay
            assert(FLAG == 0);
            FLAG_XOR(3);
            // T1 and T2 clear 0/1-bit, respectively
            WAIT_FOR(FLAG == 0);
            printf("\n"); fflush(stdout);
        }
    }

    int main() {
        create(T1);
        create(T2);
        create(Tsync);
    }
    ```
### 4.1 ç°ä»£å¤„ç†å™¨ä¹Ÿæ˜¯ (åŠ¨æ€) ç¼–è¯‘å™¨

é”™è¯¯çš„è®¤ä¸ºï¼š==ä¸€ä¸ª CPU æ‰§è¡Œä¸€æ¡æŒ‡ä»¤åˆ°è¾¾ä¸‹ä¸€çŠ¶æ€==ã€‚

ç°ä»£çš„CPUä¼šæŠŠæ±‡ç¼–æŒ‡ä»¤ç¿»è¯‘æˆæ›´å°çš„ä¸­é—´ä»£ç ([uOp](https://zhuanlan.zhihu.com/p/509264784))ï¼›

ç°ä»£å¤„ç†å™¨å–æŒ‡æ‰§è¡Œ

ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…å¯èƒ½æ‰§è¡Œå¤šæ¡æŒ‡ä»¤ï¼Œä¹Ÿå³æ˜¯ï¼š`IPC`

ç°ä»£çš„å¤„ç†å™¨å’Œç¼–è¯‘å™¨ä¸€æ ·ï¼ŒX86æœ‰éå¸¸å¤æ‚çš„è¯‘ç å‰ç«¯ï¼Œä¹Ÿä¼šå¯¹ä»£ç è¿›è¡Œä¼˜åŒ–ï¼›

``` c
// <-----------+
x = 1; //      |
y = 1; // -----+
```
x, y åœ¨å†…å­˜çš„ä¸åŒåœ°å€å¤„ï¼Œç›¸äº’ä¹‹é—´æ²¡ä»€ä¹ˆä¾èµ–ï¼Œå› æ­¤é¡ºåºå¹¶ä¸é‡è¦ï¼Œå¤„ç†å™¨å¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œè°ƒæ¢å®ƒä»¬çš„æ‰§è¡Œé¡ºåºï¼›

!!! Bç«™å¼¹å¹•ä¸­è¿˜æœ‰å¦å¤–ä¸€ç§è¯´æ³•
    
    - å³ä½¿åœ°å€ä¸åŒä¹Ÿä¸èƒ½åšæŒ‡ä»¤äº¤æ¢ï¼Œä¸è®ºæ˜¯å¼ºå†…å­˜æ¨¡å‹è¿˜æ˜¯å¼±å†…å­˜æ¨¡å‹ï¼Œå¯ä»¥äº¤æ¢çš„æ˜¯å†…å­˜çš„å¯è§æ€§ï¼Œè€Œä¸æ˜¯æŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºï¼›
    - ä¸ç®¡å¼ºå¼±å†…å­˜æ¨¡å‹ï¼Œå†…å­˜å¯è§æ€§éœ€è¦fenceå’Œbarrieræ¥ä¿è¯ï¼›

### 4.2 å®½æ¾å†…å­˜æ¨¡å‹ (Relaxed/Weak Memory Model)

[Promising 2.0ï¼šå®½æ¾å†…å­˜å¹¶å‘ä¸­çš„å…¨å±€ä¼˜åŒ–](https://zhuanlan.zhihu.com/p/431100800)

[^1]: [æ“ä½œç³»ç»Ÿï¼šè®¾è®¡ä¸å®ç° (2023 æ˜¥å­£å­¦æœŸ)](https://jyywiki.cn/OS/2023/)
[^2]: [5. å¤šå¤„ç†å™¨ç¼–ç¨‹ï¼šä»å…¥é—¨åˆ°æ”¾å¼ƒ](https://jyywiki.cn/OS/2023/build/lect5.ipynb)
[^3]: [å¤šå¤„ç†å™¨ç¼–ç¨‹ï¼šä»å…¥é—¨åˆ°æ”¾å¼ƒ (çº¿ç¨‹åº“ã€ç°ä»£å¤„ç†å™¨æ¶æ„ã€å®½æ¾å†…å­˜æ¨¡å‹) [å—äº¬å¤§å­¦2023æ“ä½œç³»ç»Ÿ-P5] (è’‹ç‚å²©)](https://www.bilibili.com/video/BV1is4y1V7Gz/?spm_id_from=333.788&vd_source=fa5dc8f5e6ad21c0ac06fd4bd377e40f)
[^4]: [Compiler Explorer](https://godbolt.org/)
[^5]: [ã€uOpså“²å­¦ä¸‰é—®ã€‘æˆ‘æ˜¯è°ï¼Ÿâ€”â€”å¸¦ä½ æ¢³ç†x86å¾®æ¶æ„](https://zhuanlan.zhihu.com/p/509264784)
